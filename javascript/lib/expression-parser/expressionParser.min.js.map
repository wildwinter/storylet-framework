{"version":3,"file":"expressionParser.min.js","sources":["../src/writer.js","../src/expression.js","../src/parser.js"],"sourcesContent":["// This file is part of an MIT-licensed project: see LICENSE file or README.md for details.\n// Copyright (c) 2025 Ian Thomas\n\nexport const STRING_FORMAT = Object.freeze({\n    SINGLEQUOTE: 0,\n    ESCAPED_SINGLEQUOTE: 1,\n    DOUBLEQUOTE: 2,\n    ESCAPED_DOUBLEQUOTE: 3,\n  });\n  \nlet _stringFormat = STRING_FORMAT.SINGLEQUOTE;\n\nexport const Writer = {\n    get StringFormat() {\n        return _stringFormat;\n    },\n    set StringFormat(value) {\n        _stringFormat = value;\n    }\n};","/*\n * This file is part of an MIT-licensed project: see LICENSE file or README.md for details.\n * Copyright (c) 2025 Ian Thomas\n */\n\nimport {\n  STRING_FORMAT,\n  Writer\n} from \"./writer.js\";\n\nexport class ExpressionNode {\n  constructor(name, precedence) {\n    if (new.target === ExpressionNode) {\n      throw new TypeError(\"Cannot instantiate abstract class ExpressionNode directly\");\n    }\n    this._name = name;\n    this._precedence = precedence;\n  }\n\n  evaluate(context, dump_eval) {\n    throw new Error(\"Abstract method 'evaluate' not implemented\");\n  }\n\n  dump_structure(indent = 0) {\n    throw new Error(\"Abstract method 'dump_structure' not implemented\");\n  }\n\n  write() {\n    throw new Error(\"Abstract method 'write' not implemented\");\n  }\n}\n\nexport class BinaryOp extends ExpressionNode {\n  constructor(name, left, op, right, precedence) {\n    super(name, precedence);\n    this._left = left;\n    this._op = op;\n    this._right = right;\n  }\n\n  evaluate(context, dump_eval) {\n    const left_val = this._left.evaluate(context, dump_eval);\n\n    const [shortCircuit, shortCircuitResult] = this._short_circuit(left_val);\n    if (shortCircuit) {\n      if (dump_eval) {\n        dump_eval.push(`Evaluated: ${_format_value(left_val)} ${this._op} (ignore) = ${_format_value(shortCircuitResult)}`);\n      }\n      return shortCircuitResult;\n    }\n\n    const right_val = this._right.evaluate(context, dump_eval);\n    const result = this._do_eval(left_val, right_val);\n\n    if (dump_eval) {\n      dump_eval.push(`Evaluated: ${_format_value(left_val)} ${this._op} ${_format_value(right_val)} = ${_format_value(result)}`);\n    }\n    return result;\n  }\n\n  _do_eval(left_val, right_val) {\n    throw new Error(\"Abstract method '_do_eval' not implemented\");\n  }\n\n  _short_circuit(left_val) {\n    // By default, do not short-circuit.\n    return [false, null];\n  }\n\n  dump_structure(indent = 0) {\n    let out = \"  \".repeat(indent) + `${this._name}\\n`;\n    out += this._left.dump_structure(indent + 1);\n    out += this._right.dump_structure(indent + 1);\n    return out;\n  }\n\n  write() {\n    let left_str = this._left.write();\n    let right_str = this._right.write();\n\n    if (this._left._precedence < this._precedence) {\n      left_str = `(${left_str})`;\n    }\n    if (this._right._precedence < this._precedence) {\n      right_str = `(${right_str})`;\n    }\n    return `${left_str} ${this._op} ${right_str}`;\n  }\n}\n\nexport class OpOr extends BinaryOp {\n  constructor(left, right) {\n    super(\"Or\", left, \"or\", right, 40);\n  }\n  _short_circuit(left_val) {\n    const result = _make_bool(left_val);\n    if (result)\n      return [true, true];\n    return [false, null];\n  }\n  _do_eval(left_val, right_val) {\n    return _make_bool(left_val) || _make_bool(right_val);\n  }\n}\n\nexport class OpAnd extends BinaryOp {\n  constructor(left, right) {\n    super(\"And\", left, \"and\", right, 50);\n  }\n  _short_circuit(left_val) {\n    const result = _make_bool(left_val);\n    if (!result)\n      return [true, false];\n    return [false, null];\n  }\n  _do_eval(left_val, right_val) {\n    return _make_bool(left_val) && _make_bool(right_val);\n  }\n}\n\nexport class OpEquals extends BinaryOp {\n  constructor(left, right) {\n    super(\"Equals\", left, \"==\", right, 60);\n  }\n  _do_eval(left_val, right_val) {\n    right_val = _make_type_match(left_val, right_val);\n    return left_val === right_val;\n  }\n}\n\nexport class OpNotEquals extends BinaryOp {\n  constructor(left, right) {\n    super(\"NotEquals\", left, \"!=\", right, 60);\n  }\n  _do_eval(left_val, right_val) {\n    right_val = _make_type_match(left_val, right_val);\n    return left_val !== right_val;\n  }\n}\n\nexport class OpPlus extends BinaryOp {\n  constructor(left, right) {\n    super(\"Plus\", left, \"+\", right, 70);\n  }\n  _do_eval(left_val, right_val) {\n    return _make_numeric(left_val) + _make_numeric(right_val);\n  }\n}\n\nexport class OpMinus extends BinaryOp {\n  constructor(left, right) {\n    super(\"Minus\", left, \"-\", right, 70);\n  }\n  _do_eval(left_val, right_val) {\n    return _make_numeric(left_val) - _make_numeric(right_val);\n  }\n}\n\nexport class OpDivide extends BinaryOp {\n  constructor(left, right) {\n    super(\"Divide\", left, \"/\", right, 85);\n  }\n  _do_eval(left_val, right_val) {\n    right_val = _make_numeric(right_val);\n    if (right_val === 0) {\n      throw new Error(\"Division by zero.\");\n    }\n    return _make_numeric(left_val) / right_val;\n  }\n}\n\nexport class OpMultiply extends BinaryOp {\n  constructor(left, right) {\n    super(\"Multiply\", left, \"*\", right, 80);\n  }\n  _short_circuit(left_val) {\n    const result = _make_numeric(left_val);\n    if (result==0)\n      return [true, 0];\n    return [false, null];\n  }\n  _do_eval(left_val, right_val) {\n    return _make_numeric(left_val) * _make_numeric(right_val);\n  }\n}\n\nexport class OpGreaterThan extends BinaryOp {\n  constructor(left, right) {\n    super(\"GreaterThan\", left, \">\", right, 60);\n  }\n  _do_eval(left_val, right_val) {\n    return _make_numeric(left_val) > _make_numeric(right_val);\n  }\n}\n\nexport class OpLessThan extends BinaryOp {\n  constructor(left, right) {\n    super(\"LessThan\", left, \"<\", right, 60);\n  }\n  _do_eval(left_val, right_val) {\n    return _make_numeric(left_val) < _make_numeric(right_val);\n  }\n}\n\nexport class OpGreaterThanEquals extends BinaryOp {\n  constructor(left, right) {\n    super(\"GreaterThanEquals\", left, \">=\", right, 60);\n  }\n  _do_eval(left_val, right_val) {\n    return _make_numeric(left_val) >= _make_numeric(right_val);\n  }\n}\n\nexport class OpLessThanEquals extends BinaryOp {\n  constructor(left, right) {\n    super(\"LessThanEquals\", left, \"<=\", right, 60);\n  }\n  _do_eval(left_val, right_val) {\n    return _make_numeric(left_val) <= _make_numeric(right_val);\n  }\n}\n\nexport class UnaryOp extends ExpressionNode {\n  constructor(name, op, operand, precedence) {\n    super(name, precedence);\n    this._operand = operand;\n    this._op = op;\n  }\n\n  evaluate(context, dump_eval) {\n    const val = this._operand.evaluate(context, dump_eval);\n    const result = this._do_eval(val);\n    if (dump_eval) {\n      dump_eval.push(`Evaluated: ${this._op} ${_format_value(val)} = ${_format_value(result)}`);\n    }\n    return result;\n  }\n\n  _do_eval(val) {\n    throw new Error(\"Abstract method '_do_eval' not implemented\");\n  }\n\n  dump_structure(indent = 0) {\n    let out = \"  \".repeat(indent) + `${this._name}\\n`;\n    out += this._operand.dump_structure(indent + 1);\n    return out;\n  }\n\n  write() {\n    let operand_str = this._operand.write();\n    if (this._operand._precedence < this._precedence) {\n      operand_str = `(${operand_str})`;\n    }\n    return `${this._op} ${operand_str}`;\n  }\n}\n\nexport class OpNegative extends UnaryOp {\n  constructor(operand) {\n    super(\"Negative\", \"-\", operand, 90);\n  }\n  _do_eval(val) {\n    return -_make_numeric(val);\n  }\n}\n\nexport class OpNot extends UnaryOp {\n  constructor(operand) {\n    super(\"Not\", \"not\", operand, 90);\n  }\n  _do_eval(val) {\n    return !_make_bool(val);\n  }\n}\n\nexport class LiteralBoolean extends ExpressionNode {\n  constructor(value) {\n    super(\"Boolean\", 100);\n    this._value = value;\n  }\n  evaluate(context, dump_eval) {\n    if (dump_eval) {\n      dump_eval.push(`Boolean: ${_format_value(this._value)}`);\n    }\n    return this._value;\n  }\n  dump_structure(indent = 0) {\n    return \"  \".repeat(indent) + `Boolean(${_format_value(this._value)})\\n`;\n  }\n  write() {\n    return _format_value(this._value);\n  }\n}\n\nexport class LiteralNumber extends ExpressionNode {\n  constructor(value) {\n    super(\"Number\", 100);\n    // Assuming value is provided as a string\n    this._value = parseFloat(value);\n  }\n  evaluate(context, dump_eval) {\n    if (dump_eval) {\n      dump_eval.push(`Number: ${this._value}`);\n    }\n    return this._value;\n  }\n  dump_structure(indent = 0) {\n    return \"  \".repeat(indent) + `Number(${this._value})\\n`;\n  }\n  write() {\n    return `${this._value}`;\n  }\n}\n\nexport class LiteralString extends ExpressionNode {\n  constructor(value) {\n    super(\"String\", 100);\n    this._value = value;\n  }\n  evaluate(context, dump_eval) {\n    if (dump_eval) {\n      dump_eval.push(`String: ${_format_string(this._value)}`);\n    }\n    return this._value;\n  }\n  dump_structure(indent = 0) {\n    return \"  \".repeat(indent) + `String(${_format_string(this._value)})\\n`;\n  }\n  write() {\n    return _format_string(this._value);\n  }\n}\n\nexport class Variable extends ExpressionNode {\n  constructor(name) {\n    super(\"Variable\", 100);\n    this._name = name;\n  }\n  evaluate(context, dump_eval) {\n    const value = context[this._name];\n    if (value === undefined) {\n      throw new Error(`Variable '${this._name}' not found in context.`);\n    }\n    if (typeof value !== \"number\" && typeof value !== \"boolean\" && typeof value !== \"string\") {\n      throw new TypeError(`Variable '${this._name}' must return bool, string, or numeric.`);\n    }\n    if (dump_eval) {\n      dump_eval.push(`Fetching variable: ${this._name} -> ${_format_value(value)}`);\n    }\n    return value;\n  }\n  dump_structure(indent = 0) {\n    return \"  \".repeat(indent) + `Variable(${this._name})\\n`;\n  }\n  write() {\n    return this._name;\n  }\n}\n\nexport class FunctionCall extends ExpressionNode {\n  constructor(func_name, args = []) {\n    super(\"FunctionCall\", 100);\n    this._func_name = func_name;\n    this._args = args;\n  }\n  evaluate(context, dump_eval) {\n    const func = context[this._func_name];\n    if (func === undefined) {\n      throw new Error(`Function '${this._func_name}' not found in context.`);\n    }\n    const arg_values = this._args.map(arg => arg.evaluate(context, dump_eval));\n\n    // Check function arity using func.length\n    if (arg_values.length !== func.length) {\n      const formattedArgs = arg_values.map(val => _format_value(val)).join(\", \");\n      throw new Error(`Function '${this._func_name}' does not support the provided arguments (${formattedArgs}).`);\n    }\n\n    const result = func(...arg_values);\n\n    if (typeof result !== \"number\" && typeof result !== \"boolean\" && typeof result !== \"string\") {\n      throw new TypeError(`Function '${this._func_name}' must return bool, string, or numeric.`);\n    }\n    if (dump_eval) {\n      const formattedArgs = arg_values.map(val => _format_value(val)).join(\", \");\n      dump_eval.push(`Called function: ${this._func_name}(${formattedArgs}) = ${_format_value(result)}`);\n    }\n    return result;\n  }\n  dump_structure(indent = 0) {\n    let out = \"  \".repeat(indent) + `FunctionCall(${this._func_name})\\n`;\n    for (const arg of this._args) {\n      out += arg.dump_structure(indent + 1);\n    }\n    return out;\n  }\n  write() {\n    const written_args = this._args.map(arg => arg.write());\n    return `${this._func_name}(${written_args.join(\", \")})`;\n  }\n}\n\nfunction _make_bool(val) {\n  if (typeof val === \"boolean\") {\n    return val;\n  }\n  if (typeof val === \"number\") {\n    return val !== 0;\n  }\n  if (typeof val === \"string\") {\n    return val.toLowerCase() === \"true\" || val === \"1\";\n  }\n  throw new TypeError(`Type mismatch: Expecting bool, but got '${val}'`);\n}\n\nfunction _make_str(val) {\n  if (typeof val === \"string\") {\n    return val;\n  }\n  if (typeof val === \"boolean\") {\n    return val ? \"true\" : \"false\";\n  }\n  if (typeof val === \"number\") {\n    return val.toString();\n  }\n  throw new TypeError(`Type mismatch: Expecting string but got '${val}'`);\n}\n\nfunction _make_numeric(val) {\n  if (typeof val === \"boolean\") {\n    return val ? 1 : 0;\n  }\n  if (typeof val === \"number\") {\n    return val;\n  }\n  if (typeof val === \"string\") {\n    const numericRegex = /^-?\\d+(\\.\\d+)?$/;\n    if (numericRegex.test(val)) {\n      return parseFloat(val);\n    }\n  }\n  throw new TypeError(`Type mismatch: Expecting number but got '${val}'`);\n}\n\nfunction _make_type_match(left_val, right_val) {\n  if (typeof left_val === \"boolean\") {\n    return _make_bool(right_val);\n  }\n  if (typeof left_val === \"number\") {\n    return _make_numeric(right_val);\n  }\n  if (typeof left_val === \"string\") {\n    return _make_str(right_val);\n  }\n  throw new TypeError(`Type mismatch: unrecognised type for '${left_val}'`);\n}\n\nfunction _format_string(val) {\n  switch (Writer.StringFormat) {\n    case STRING_FORMAT.SINGLEQUOTE:\n      return `'${val}'`;\n    case STRING_FORMAT.ESCAPED_SINGLEQUOTE:\n      return `\\\\'${val}\\\\'`;\n    case STRING_FORMAT.ESCAPED_DOUBLEQUOTE:\n      return `\\\\\"${val}\\\\\"`;\n    case STRING_FORMAT.DOUBLEQUOTE:\n    default:\n      return `\"${val}\"`;\n  }\n}\n\nfunction _format_value(val) {\n  if (typeof val === \"string\") {\n    return _format_string(val);\n  }\n  return val.toString();\n}","// This file is part of an MIT-licensed project: see LICENSE file or README.md for details.\n// Copyright (c) 2025 Ian Thomas\n\nimport {\n    ExpressionNode,\n    LiteralBoolean,\n    LiteralNumber,\n    LiteralString,\n    OpAnd,\n    OpDivide,\n    OpEquals,\n    OpGreaterThan,\n    OpGreaterThanEquals,\n    OpLessThan,\n    OpLessThanEquals,\n    OpMinus,\n    OpMultiply,\n    OpNegative,\n    OpNot,\n    OpNotEquals,\n    OpOr,\n    OpPlus,\n    Variable,\n    FunctionCall,\n  } from \"./expression.js\";\n  \n  // A JavaScript regular expression for tokenizing the expression.\n  // The pattern below mirrors the Python TOKEN_REGEX from your parser.\n  // Note: The \"g\" flag (global) is used for repeated matching.\n  const TOKEN_REGEX = /\\s*(>=|<=|==|=|!=|>|<|\\(|\\)|,|and|&&|or|\\|\\||not|!|\\+|\\-|\\/|\\*|[A-Za-z_][A-Za-z0-9_]*|-?\\d+\\.\\d+|-?\\d+|\"[^\"]*\"|'[^']*'|true|false|True|False)\\s*/g;\n  \n  export class ExpressionParser {\n    constructor() {\n      this._tokens = [];\n      this._pos = 0;\n    }\n  \n    /**\n     * Parses the given expression string into an AST (ExpressionNode).\n     * @param {string} expression \n     * @returns {ExpressionNode}\n     */\n    parse(expression) {\n      this._tokens = this.tokenize(expression);\n      this._pos = 0;\n      const node = this._parse_or();\n  \n      if (this._pos < this._tokens.length) {\n        throw new SyntaxError(\n          `Unexpected token '${this._tokens[this._pos]}' at position ${this._pos}`\n        );\n      }\n      return node;\n    }\n  \n    /**\n     * Tokenizes the input expression string.\n     * @param {string} expression \n     * @returns {string[]}\n     */\n    tokenize(expression) {\n        const matches = expression.matchAll(TOKEN_REGEX);\n        const tokens = [];\n        for (const match of matches) {\n          // match[1] contains the captured token (without surrounding whitespace)\n          if (match[1]) {\n            tokens.push(match[1]);\n          }\n        }\n\n        if (tokens.length === 0) {\n          throw new SyntaxError(`No tokens were recognized in expression: '${expression}'`);\n        }\n        return tokens;\n      }\n\n    _parse_or() {\n      let node = this._parse_and();\n      while (this._match(\"or\") || this._match(\"||\")) {\n        node = new OpOr(node, this._parse_and());\n      }\n      return node;\n    }\n  \n    _parse_and() {\n      let node = this._parse_binary_op();\n      while (this._match(\"and\") || this._match(\"&&\")) {\n        node = new OpAnd(node, this._parse_binary_op());\n      }\n      return node;\n    }\n  \n    _parse_math_add_sub() {\n      let node = this._parse_math_mul_div();\n      while (this._match(\"+\", \"-\")) {\n        const op = this._previous() || \"\";\n        if (op === \"+\") {\n          node = new OpPlus(node, this._parse_math_mul_div());\n        } else {\n          node = new OpMinus(node, this._parse_math_mul_div());\n        }\n      }\n      return node;\n    }\n  \n    _parse_math_mul_div() {\n      let node = this._parse_unary_op();\n      while (this._match(\"*\", \"/\")) {\n        const op = this._previous() || \"\";\n        if (op === \"*\") {\n          node = new OpMultiply(node, this._parse_unary_op());\n        } else {\n          node = new OpDivide(node, this._parse_unary_op());\n        }\n      }\n      return node;\n    }\n  \n    _parse_binary_op() {\n      let node = this._parse_math_add_sub();\n      while (this._match(\"==\", \"!=\", \">\", \"<\", \">=\", \"<=\", \"=\")) {\n        const op = this._previous() || \"\";\n        if (op === \"=\" || op === \"==\") {\n          node = new OpEquals(node, this._parse_math_add_sub());\n        } else if (op === \"!=\") {\n          node = new OpNotEquals(node, this._parse_math_add_sub());\n        } else if (op === \">\") {\n          node = new OpGreaterThan(node, this._parse_math_add_sub());\n        } else if (op === \"<\") {\n          node = new OpLessThan(node, this._parse_math_add_sub());\n        } else if (op === \">=\") {\n          node = new OpGreaterThanEquals(node, this._parse_math_add_sub());\n        } else if (op === \"<=\") {\n          node = new OpLessThanEquals(node, this._parse_math_add_sub());\n        }\n      }\n      return node;\n    }\n  \n    _parse_unary_op() {\n      if (this._match(\"not\") || this._match(\"!\")) {\n        return new OpNot(this._parse_unary_op());\n      } else if (this._match(\"-\")) {\n        return new OpNegative(this._parse_unary_op());\n      }\n      return this._parse_term();\n    }\n  \n    _parse_string_literal() {\n      const stringVal = this._peek();\n      if (\n        stringVal &&\n        ((stringVal.startsWith('\"') && stringVal.endsWith('\"')) ||\n          (stringVal.startsWith(\"'\") && stringVal.endsWith(\"'\")))\n      ) {\n        this._advance();\n        return new LiteralString(stringVal.slice(1, -1));\n      }\n      return null;\n    }\n  \n    _parse_term() {\n      if (this._match(\"(\")) {\n        const node = this._parse_or();\n        this._consume(\")\");\n        return node;\n      } else if (this._match(\"true\") || this._match(\"True\")) {\n        return new LiteralBoolean(true);\n      } else if (this._match(\"false\") || this._match(\"False\")) {\n        return new LiteralBoolean(false);\n      } else if (/^-?\\d+(\\.\\d+)?$/.test(this._peek() || \"\")) {\n        return new LiteralNumber(this._advance() || \"\");\n      }\n  \n      const stringLiteral = this._parse_string_literal();\n      if (stringLiteral !== null) {\n        return stringLiteral;\n      }\n  \n      const identifier = this._match_identifier();\n      if (identifier) {\n        if (this._match(\"(\")) {\n          const args = [];\n          if (!this._match(\")\")) {\n            args.push(this._parse_or());\n            while (this._match(\",\")) {\n              args.push(this._parse_or());\n            }\n            this._consume(\")\");\n          }\n          return new FunctionCall(identifier, args);\n        }\n        return new Variable(identifier);\n      }\n      throw new SyntaxError(`Unexpected token: ${this._peek()}`);\n    }\n  \n    _match(...expectedTokens) {\n      if (this._pos < this._tokens.length && expectedTokens.includes(this._tokens[this._pos])) {\n        this._pos++;\n        return true;\n      }\n      return false;\n    }\n  \n    _consume(expectedToken) {\n      if (this._match(expectedToken)) {\n        return;\n      }\n      if (this._pos >= this._tokens.length) {\n        throw new SyntaxError(`Expected '${expectedToken}' but expression ended.`);\n      }\n      throw new SyntaxError(`Expected '${expectedToken}' but found '${this._peek()}'`);\n    }\n  \n    _peek() {\n      return this._pos < this._tokens.length ? this._tokens[this._pos] : null;\n    }\n  \n    _previous() {\n      return this._pos > 0 ? this._tokens[this._pos - 1] : null;\n    }\n  \n    _advance() {\n      if (this._pos < this._tokens.length) {\n        this._pos++;\n        return this._tokens[this._pos - 1];\n      }\n      return null;\n    }\n  \n    _expect(expectedToken) {\n      const token = this._advance();\n      if (token !== expectedToken) {\n        throw new SyntaxError(`Expected '${expectedToken}', but found '${token}'`);\n      }\n      return token;\n    }\n  \n    _match_identifier() {\n      if (this._pos < this._tokens.length && /^[A-Za-z_][A-Za-z0-9_]*$/.test(this._tokens[this._pos])) {\n        const token = this._tokens[this._pos];\n        this._pos++;\n        return token;\n      }\n      return null;\n    }\n  }"],"names":["STRING_FORMAT","Object","freeze","SINGLEQUOTE","ESCAPED_SINGLEQUOTE","DOUBLEQUOTE","ESCAPED_DOUBLEQUOTE","_stringFormat","Writer","StringFormat","value","ExpressionNode","constructor","name","precedence","TypeError","this","_name","_precedence","evaluate","context","dump_eval","Error","dump_structure","indent","write","BinaryOp","left","op","right","super","_left","_op","_right","left_val","shortCircuit","shortCircuitResult","_short_circuit","push","_format_value","right_val","result","_do_eval","out","repeat","left_str","right_str","OpOr","_make_bool","OpAnd","OpEquals","_make_type_match","OpNotEquals","OpPlus","_make_numeric","OpMinus","OpDivide","OpMultiply","OpGreaterThan","OpLessThan","OpGreaterThanEquals","OpLessThanEquals","UnaryOp","operand","_operand","val","operand_str","OpNegative","OpNot","LiteralBoolean","_value","LiteralNumber","parseFloat","LiteralString","_format_string","Variable","undefined","FunctionCall","func_name","args","_func_name","_args","func","arg_values","map","arg","length","formattedArgs","join","written_args","toLowerCase","test","toString","_make_str","TOKEN_REGEX","_tokens","_pos","parse","expression","tokenize","node","_parse_or","SyntaxError","matches","matchAll","tokens","match","_parse_and","_match","_parse_binary_op","_parse_math_add_sub","_parse_math_mul_div","_previous","_parse_unary_op","_parse_term","_parse_string_literal","stringVal","_peek","startsWith","endsWith","_advance","slice","_consume","stringLiteral","identifier","_match_identifier","expectedTokens","includes","expectedToken","_expect","token"],"mappings":"8CAGY,MAACA,EAAgBC,OAAOC,OAAO,CACvCC,YAAa,EACbC,oBAAqB,EACrBC,YAAa,EACbC,oBAAqB,IAGzB,IAAIC,EAAgBP,EAAcG,YAEtB,MAACK,EAAS,CAClB,gBAAIC,GACA,OAAOF,CACV,EACD,gBAAIE,CAAaC,GACbH,EAAgBG,CACxB,GCRO,MAAMC,EACX,WAAAC,CAAYC,EAAMC,GAChB,gBAAmBH,EACjB,MAAM,IAAII,UAAU,6DAEtBC,KAAKC,MAAQJ,EACbG,KAAKE,YAAcJ,CACvB,CAEE,QAAAK,CAASC,EAASC,GAChB,MAAM,IAAIC,MAAM,6CACpB,CAEE,cAAAC,CAAeC,EAAS,GACtB,MAAM,IAAIF,MAAM,mDACpB,CAEE,KAAAG,GACE,MAAM,IAAIH,MAAM,0CACpB,EAGO,MAAMI,UAAiBf,EAC5B,WAAAC,CAAYC,EAAMc,EAAMC,EAAIC,EAAOf,GACjCgB,MAAMjB,EAAMC,GACZE,KAAKe,MAAQJ,EACbX,KAAKgB,IAAMJ,EACXZ,KAAKiB,OAASJ,CAClB,CAEE,QAAAV,CAASC,EAASC,GAChB,MAAMa,EAAWlB,KAAKe,MAAMZ,SAASC,EAASC,IAEvCc,EAAcC,GAAsBpB,KAAKqB,eAAeH,GAC/D,GAAIC,EAIF,OAHId,GACFA,EAAUiB,KAAK,cAAcC,EAAcL,MAAalB,KAAKgB,kBAAkBO,EAAcH,MAExFA,EAGT,MAAMI,EAAYxB,KAAKiB,OAAOd,SAASC,EAASC,GAC1CoB,EAASzB,KAAK0B,SAASR,EAAUM,GAKvC,OAHInB,GACFA,EAAUiB,KAAK,cAAcC,EAAcL,MAAalB,KAAKgB,OAAOO,EAAcC,QAAgBD,EAAcE,MAE3GA,CACX,CAEE,QAAAC,CAASR,EAAUM,GACjB,MAAM,IAAIlB,MAAM,6CACpB,CAEE,cAAAe,CAAeH,GAEb,MAAO,EAAC,EAAO,KACnB,CAEE,cAAAX,CAAeC,EAAS,GACtB,IAAImB,EAAM,KAAKC,OAAOpB,GAAU,GAAGR,KAAKC,UAGxC,OAFA0B,GAAO3B,KAAKe,MAAMR,eAAeC,EAAS,GAC1CmB,GAAO3B,KAAKiB,OAAOV,eAAeC,EAAS,GACpCmB,CACX,CAEE,KAAAlB,GACE,IAAIoB,EAAW7B,KAAKe,MAAMN,QACtBqB,EAAY9B,KAAKiB,OAAOR,QAQ5B,OANIT,KAAKe,MAAMb,YAAcF,KAAKE,cAChC2B,EAAW,IAAIA,MAEb7B,KAAKiB,OAAOf,YAAcF,KAAKE,cACjC4B,EAAY,IAAIA,MAEX,GAAGD,KAAY7B,KAAKgB,OAAOc,GACtC,EAGO,MAAMC,UAAarB,EACxB,WAAAd,CAAYe,EAAME,GAChBC,MAAM,KAAMH,EAAM,KAAME,EAAO,GACnC,CACE,cAAAQ,CAAeH,GAEb,OADec,EAAWd,GAEjB,EAAC,GAAM,GACT,EAAC,EAAO,KACnB,CACE,QAAAQ,CAASR,EAAUM,GACjB,OAAOQ,EAAWd,IAAac,EAAWR,EAC9C,EAGO,MAAMS,UAAcvB,EACzB,WAAAd,CAAYe,EAAME,GAChBC,MAAM,MAAOH,EAAM,MAAOE,EAAO,GACrC,CACE,cAAAQ,CAAeH,GAEb,OADec,EAAWd,GAGnB,EAAC,EAAO,MADN,EAAC,GAAM,EAEpB,CACE,QAAAQ,CAASR,EAAUM,GACjB,OAAOQ,EAAWd,IAAac,EAAWR,EAC9C,EAGO,MAAMU,UAAiBxB,EAC5B,WAAAd,CAAYe,EAAME,GAChBC,MAAM,SAAUH,EAAM,KAAME,EAAO,GACvC,CACE,QAAAa,CAASR,EAAUM,GAEjB,OAAON,KADPM,EAAYW,EAAiBjB,EAAUM,GAE3C,EAGO,MAAMY,UAAoB1B,EAC/B,WAAAd,CAAYe,EAAME,GAChBC,MAAM,YAAaH,EAAM,KAAME,EAAO,GAC1C,CACE,QAAAa,CAASR,EAAUM,GAEjB,OAAON,KADPM,EAAYW,EAAiBjB,EAAUM,GAE3C,EAGO,MAAMa,UAAe3B,EAC1B,WAAAd,CAAYe,EAAME,GAChBC,MAAM,OAAQH,EAAM,IAAKE,EAAO,GACpC,CACE,QAAAa,CAASR,EAAUM,GACjB,OAAOc,EAAcpB,GAAYoB,EAAcd,EACnD,EAGO,MAAMe,UAAgB7B,EAC3B,WAAAd,CAAYe,EAAME,GAChBC,MAAM,QAASH,EAAM,IAAKE,EAAO,GACrC,CACE,QAAAa,CAASR,EAAUM,GACjB,OAAOc,EAAcpB,GAAYoB,EAAcd,EACnD,EAGO,MAAMgB,UAAiB9B,EAC5B,WAAAd,CAAYe,EAAME,GAChBC,MAAM,SAAUH,EAAM,IAAKE,EAAO,GACtC,CACE,QAAAa,CAASR,EAAUM,GAEjB,GAAkB,KADlBA,EAAYc,EAAcd,IAExB,MAAM,IAAIlB,MAAM,qBAElB,OAAOgC,EAAcpB,GAAYM,CACrC,EAGO,MAAMiB,UAAmB/B,EAC9B,WAAAd,CAAYe,EAAME,GAChBC,MAAM,WAAYH,EAAM,IAAKE,EAAO,GACxC,CACE,cAAAQ,CAAeH,GAEb,OAAY,GADGoB,EAAcpB,GAEpB,EAAC,EAAM,GACT,EAAC,EAAO,KACnB,CACE,QAAAQ,CAASR,EAAUM,GACjB,OAAOc,EAAcpB,GAAYoB,EAAcd,EACnD,EAGO,MAAMkB,UAAsBhC,EACjC,WAAAd,CAAYe,EAAME,GAChBC,MAAM,cAAeH,EAAM,IAAKE,EAAO,GAC3C,CACE,QAAAa,CAASR,EAAUM,GACjB,OAAOc,EAAcpB,GAAYoB,EAAcd,EACnD,EAGO,MAAMmB,UAAmBjC,EAC9B,WAAAd,CAAYe,EAAME,GAChBC,MAAM,WAAYH,EAAM,IAAKE,EAAO,GACxC,CACE,QAAAa,CAASR,EAAUM,GACjB,OAAOc,EAAcpB,GAAYoB,EAAcd,EACnD,EAGO,MAAMoB,UAA4BlC,EACvC,WAAAd,CAAYe,EAAME,GAChBC,MAAM,oBAAqBH,EAAM,KAAME,EAAO,GAClD,CACE,QAAAa,CAASR,EAAUM,GACjB,OAAOc,EAAcpB,IAAaoB,EAAcd,EACpD,EAGO,MAAMqB,UAAyBnC,EACpC,WAAAd,CAAYe,EAAME,GAChBC,MAAM,iBAAkBH,EAAM,KAAME,EAAO,GAC/C,CACE,QAAAa,CAASR,EAAUM,GACjB,OAAOc,EAAcpB,IAAaoB,EAAcd,EACpD,EAGO,MAAMsB,UAAgBnD,EAC3B,WAAAC,CAAYC,EAAMe,EAAImC,EAASjD,GAC7BgB,MAAMjB,EAAMC,GACZE,KAAKgD,SAAWD,EAChB/C,KAAKgB,IAAMJ,CACf,CAEE,QAAAT,CAASC,EAASC,GAChB,MAAM4C,EAAMjD,KAAKgD,SAAS7C,SAASC,EAASC,GACtCoB,EAASzB,KAAK0B,SAASuB,GAI7B,OAHI5C,GACFA,EAAUiB,KAAK,cAActB,KAAKgB,OAAOO,EAAc0B,QAAU1B,EAAcE,MAE1EA,CACX,CAEE,QAAAC,CAASuB,GACP,MAAM,IAAI3C,MAAM,6CACpB,CAEE,cAAAC,CAAeC,EAAS,GACtB,IAAImB,EAAM,KAAKC,OAAOpB,GAAU,GAAGR,KAAKC,UAExC,OADA0B,GAAO3B,KAAKgD,SAASzC,eAAeC,EAAS,GACtCmB,CACX,CAEE,KAAAlB,GACE,IAAIyC,EAAclD,KAAKgD,SAASvC,QAIhC,OAHIT,KAAKgD,SAAS9C,YAAcF,KAAKE,cACnCgD,EAAc,IAAIA,MAEb,GAAGlD,KAAKgB,OAAOkC,GAC1B,EAGO,MAAMC,UAAmBL,EAC9B,WAAAlD,CAAYmD,GACVjC,MAAM,WAAY,IAAKiC,EAAS,GACpC,CACE,QAAArB,CAASuB,GACP,OAAQX,EAAcW,EAC1B,EAGO,MAAMG,UAAcN,EACzB,WAAAlD,CAAYmD,GACVjC,MAAM,MAAO,MAAOiC,EAAS,GACjC,CACE,QAAArB,CAASuB,GACP,OAAQjB,EAAWiB,EACvB,EAGO,MAAMI,UAAuB1D,EAClC,WAAAC,CAAYF,GACVoB,MAAM,UAAW,KACjBd,KAAKsD,OAAS5D,CAClB,CACE,QAAAS,CAASC,EAASC,GAIhB,OAHIA,GACFA,EAAUiB,KAAK,YAAYC,EAAcvB,KAAKsD,WAEzCtD,KAAKsD,MAChB,CACE,cAAA/C,CAAeC,EAAS,GACtB,MAAO,KAAKoB,OAAOpB,GAAU,WAAWe,EAAcvB,KAAKsD,YAC/D,CACE,KAAA7C,GACE,OAAOc,EAAcvB,KAAKsD,OAC9B,EAGO,MAAMC,UAAsB5D,EACjC,WAAAC,CAAYF,GACVoB,MAAM,SAAU,KAEhBd,KAAKsD,OAASE,WAAW9D,EAC7B,CACE,QAAAS,CAASC,EAASC,GAIhB,OAHIA,GACFA,EAAUiB,KAAK,WAAWtB,KAAKsD,UAE1BtD,KAAKsD,MAChB,CACE,cAAA/C,CAAeC,EAAS,GACtB,MAAO,KAAKoB,OAAOpB,GAAU,UAAUR,KAAKsD,WAChD,CACE,KAAA7C,GACE,MAAO,GAAGT,KAAKsD,QACnB,EAGO,MAAMG,UAAsB9D,EACjC,WAAAC,CAAYF,GACVoB,MAAM,SAAU,KAChBd,KAAKsD,OAAS5D,CAClB,CACE,QAAAS,CAASC,EAASC,GAIhB,OAHIA,GACFA,EAAUiB,KAAK,WAAWoC,EAAe1D,KAAKsD,WAEzCtD,KAAKsD,MAChB,CACE,cAAA/C,CAAeC,EAAS,GACtB,MAAO,KAAKoB,OAAOpB,GAAU,UAAUkD,EAAe1D,KAAKsD,YAC/D,CACE,KAAA7C,GACE,OAAOiD,EAAe1D,KAAKsD,OAC/B,EAGO,MAAMK,UAAiBhE,EAC5B,WAAAC,CAAYC,GACViB,MAAM,WAAY,KAClBd,KAAKC,MAAQJ,CACjB,CACE,QAAAM,CAASC,EAASC,GAChB,MAAMX,EAAQU,EAAQJ,KAAKC,OAC3B,QAAc2D,IAAVlE,EACF,MAAM,IAAIY,MAAM,aAAaN,KAAKC,gCAEpC,GAAqB,iBAAVP,GAAuC,kBAAVA,GAAwC,iBAAVA,EACpE,MAAM,IAAIK,UAAU,aAAaC,KAAKC,gDAKxC,OAHII,GACFA,EAAUiB,KAAK,sBAAsBtB,KAAKC,YAAYsB,EAAc7B,MAE/DA,CACX,CACE,cAAAa,CAAeC,EAAS,GACtB,MAAO,KAAKoB,OAAOpB,GAAU,YAAYR,KAAKC,UAClD,CACE,KAAAQ,GACE,OAAOT,KAAKC,KAChB,EAGO,MAAM4D,UAAqBlE,EAChC,WAAAC,CAAYkE,EAAWC,EAAO,IAC5BjD,MAAM,eAAgB,KACtBd,KAAKgE,WAAaF,EAClB9D,KAAKiE,MAAQF,CACjB,CACE,QAAA5D,CAASC,EAASC,GAChB,MAAM6D,EAAO9D,EAAQJ,KAAKgE,YAC1B,QAAaJ,IAATM,EACF,MAAM,IAAI5D,MAAM,aAAaN,KAAKgE,qCAEpC,MAAMG,EAAanE,KAAKiE,MAAMG,KAAIC,GAAOA,EAAIlE,SAASC,EAASC,KAG/D,GAAI8D,EAAWG,SAAWJ,EAAKI,OAAQ,CACrC,MAAMC,EAAgBJ,EAAWC,KAAInB,GAAO1B,EAAc0B,KAAMuB,KAAK,MACrE,MAAM,IAAIlE,MAAM,aAAaN,KAAKgE,wDAAwDO,MAChG,CAEI,MAAM9C,EAASyC,KAAQC,GAEvB,GAAsB,iBAAX1C,GAAyC,kBAAXA,GAA0C,iBAAXA,EACtE,MAAM,IAAI1B,UAAU,aAAaC,KAAKgE,qDAExC,GAAI3D,EAAW,CACb,MAAMkE,EAAgBJ,EAAWC,KAAInB,GAAO1B,EAAc0B,KAAMuB,KAAK,MACrEnE,EAAUiB,KAAK,oBAAoBtB,KAAKgE,cAAcO,QAAoBhD,EAAcE,KAC9F,CACI,OAAOA,CACX,CACE,cAAAlB,CAAeC,EAAS,GACtB,IAAImB,EAAM,KAAKC,OAAOpB,GAAU,gBAAgBR,KAAKgE,gBACrD,IAAK,MAAMK,KAAOrE,KAAKiE,MACrBtC,GAAO0C,EAAI9D,eAAeC,EAAS,GAErC,OAAOmB,CACX,CACE,KAAAlB,GACE,MAAMgE,EAAezE,KAAKiE,MAAMG,KAAIC,GAAOA,EAAI5D,UAC/C,MAAO,GAAGT,KAAKgE,cAAcS,EAAaD,KAAK,QACnD,EAGA,SAASxC,EAAWiB,GAClB,GAAmB,kBAARA,EACT,OAAOA,EAET,GAAmB,iBAARA,EACT,OAAe,IAARA,EAET,GAAmB,iBAARA,EACT,MAA6B,SAAtBA,EAAIyB,eAAoC,MAARzB,EAEzC,MAAM,IAAIlD,UAAU,2CAA2CkD,KACjE,CAeA,SAASX,EAAcW,GACrB,GAAmB,kBAARA,EACT,OAAOA,EAAM,EAAI,EAEnB,GAAmB,iBAARA,EACT,OAAOA,EAET,GAAmB,iBAARA,EAAkB,CAE3B,GADqB,kBACJ0B,KAAK1B,GACpB,OAAOO,WAAWP,EAExB,CACE,MAAM,IAAIlD,UAAU,4CAA4CkD,KAClE,CAEA,SAASd,EAAiBjB,EAAUM,GAClC,GAAwB,kBAAbN,EACT,OAAOc,EAAWR,GAEpB,GAAwB,iBAAbN,EACT,OAAOoB,EAAcd,GAEvB,GAAwB,iBAAbN,EACT,OArCJ,SAAmB+B,GACjB,GAAmB,iBAARA,EACT,OAAOA,EAET,GAAmB,kBAARA,EACT,OAAOA,EAAM,OAAS,QAExB,GAAmB,iBAARA,EACT,OAAOA,EAAI2B,WAEb,MAAM,IAAI7E,UAAU,4CAA4CkD,KAClE,CA0BW4B,CAAUrD,GAEnB,MAAM,IAAIzB,UAAU,yCAAyCmB,KAC/D,CAEA,SAASwC,EAAeT,GACtB,OAAQzD,EAAOC,cACb,KAAKT,EAAcG,YACjB,MAAO,IAAI8D,KACb,KAAKjE,EAAcI,oBACjB,MAAO,MAAM6D,OACf,KAAKjE,EAAcM,oBACjB,MAAO,MAAM2D,OACf,KAAKjE,EAAcK,YACnB,QACE,MAAO,IAAI4D,KAEjB,CAEA,SAAS1B,EAAc0B,GACrB,MAAmB,iBAARA,EACFS,EAAeT,GAEjBA,EAAI2B,UACb,CC/bE,MAAME,EAAc,8MAEb,MACL,WAAAlF,GACEI,KAAK+E,QAAU,GACf/E,KAAKgF,KAAO,CAClB,CAOI,KAAAC,CAAMC,GACJlF,KAAK+E,QAAU/E,KAAKmF,SAASD,GAC7BlF,KAAKgF,KAAO,EACZ,MAAMI,EAAOpF,KAAKqF,YAElB,GAAIrF,KAAKgF,KAAOhF,KAAK+E,QAAQT,OAC3B,MAAM,IAAIgB,YACR,qBAAqBtF,KAAK+E,QAAQ/E,KAAKgF,sBAAsBhF,KAAKgF,QAGtE,OAAOI,CACb,CAOI,QAAAD,CAASD,GACL,MAAMK,EAAUL,EAAWM,SAASV,GAC9BW,EAAS,GACf,IAAK,MAAMC,KAASH,EAEdG,EAAM,IACRD,EAAOnE,KAAKoE,EAAM,IAItB,GAAsB,IAAlBD,EAAOnB,OACT,MAAM,IAAIgB,YAAY,6CAA6CJ,MAErE,OAAOO,CACf,CAEI,SAAAJ,GACE,IAAID,EAAOpF,KAAK2F,aAChB,KAAO3F,KAAK4F,OAAO,OAAS5F,KAAK4F,OAAO,OACtCR,EAAO,IAAIrD,EAAKqD,EAAMpF,KAAK2F,cAE7B,OAAOP,CACb,CAEI,UAAAO,GACE,IAAIP,EAAOpF,KAAK6F,mBAChB,KAAO7F,KAAK4F,OAAO,QAAU5F,KAAK4F,OAAO,OACvCR,EAAO,IAAInD,EAAMmD,EAAMpF,KAAK6F,oBAE9B,OAAOT,CACb,CAEI,mBAAAU,GACE,IAAIV,EAAOpF,KAAK+F,sBAChB,KAAO/F,KAAK4F,OAAO,IAAK,MAAM,CAG1BR,EADS,OADApF,KAAKgG,aAAe,IAEtB,IAAI3D,EAAO+C,EAAMpF,KAAK+F,uBAEtB,IAAIxD,EAAQ6C,EAAMpF,KAAK+F,sBAExC,CACM,OAAOX,CACb,CAEI,mBAAAW,GACE,IAAIX,EAAOpF,KAAKiG,kBAChB,KAAOjG,KAAK4F,OAAO,IAAK,MAAM,CAG1BR,EADS,OADApF,KAAKgG,aAAe,IAEtB,IAAIvD,EAAW2C,EAAMpF,KAAKiG,mBAE1B,IAAIzD,EAAS4C,EAAMpF,KAAKiG,kBAEzC,CACM,OAAOb,CACb,CAEI,gBAAAS,GACE,IAAIT,EAAOpF,KAAK8F,sBAChB,KAAO9F,KAAK4F,OAAO,KAAM,KAAM,IAAK,IAAK,KAAM,KAAM,MAAM,CACzD,MAAMhF,EAAKZ,KAAKgG,aAAe,GACpB,MAAPpF,GAAqB,OAAPA,EAChBwE,EAAO,IAAIlD,EAASkD,EAAMpF,KAAK8F,uBACf,OAAPlF,EACTwE,EAAO,IAAIhD,EAAYgD,EAAMpF,KAAK8F,uBAClB,MAAPlF,EACTwE,EAAO,IAAI1C,EAAc0C,EAAMpF,KAAK8F,uBACpB,MAAPlF,EACTwE,EAAO,IAAIzC,EAAWyC,EAAMpF,KAAK8F,uBACjB,OAAPlF,EACTwE,EAAO,IAAIxC,EAAoBwC,EAAMpF,KAAK8F,uBAC1B,OAAPlF,IACTwE,EAAO,IAAIvC,EAAiBuC,EAAMpF,KAAK8F,uBAEjD,CACM,OAAOV,CACb,CAEI,eAAAa,GACE,OAAIjG,KAAK4F,OAAO,QAAU5F,KAAK4F,OAAO,KAC7B,IAAIxC,EAAMpD,KAAKiG,mBACbjG,KAAK4F,OAAO,KACd,IAAIzC,EAAWnD,KAAKiG,mBAEtBjG,KAAKkG,aAClB,CAEI,qBAAAC,GACE,MAAMC,EAAYpG,KAAKqG,QACvB,OACED,IACEA,EAAUE,WAAW,MAAQF,EAAUG,SAAS,MAC/CH,EAAUE,WAAW,MAAQF,EAAUG,SAAS,OAEnDvG,KAAKwG,WACE,IAAI/C,EAAc2C,EAAUK,MAAM,GAAK,KAEzC,IACb,CAEI,WAAAP,GACE,GAAIlG,KAAK4F,OAAO,KAAM,CACpB,MAAMR,EAAOpF,KAAKqF,YAElB,OADArF,KAAK0G,SAAS,KACPtB,CACf,CAAa,GAAIpF,KAAK4F,OAAO,SAAW5F,KAAK4F,OAAO,QAC5C,OAAO,IAAIvC,GAAe,GACrB,GAAIrD,KAAK4F,OAAO,UAAY5F,KAAK4F,OAAO,SAC7C,OAAO,IAAIvC,GAAe,GACrB,GAAI,kBAAkBsB,KAAK3E,KAAKqG,SAAW,IAChD,OAAO,IAAI9C,EAAcvD,KAAKwG,YAAc,IAG9C,MAAMG,EAAgB3G,KAAKmG,wBAC3B,GAAsB,OAAlBQ,EACF,OAAOA,EAGT,MAAMC,EAAa5G,KAAK6G,oBACxB,GAAID,EAAY,CACd,GAAI5G,KAAK4F,OAAO,KAAM,CACpB,MAAM7B,EAAO,GACb,IAAK/D,KAAK4F,OAAO,KAAM,CAErB,IADA7B,EAAKzC,KAAKtB,KAAKqF,aACRrF,KAAK4F,OAAO,MACjB7B,EAAKzC,KAAKtB,KAAKqF,aAEjBrF,KAAK0G,SAAS,IAC1B,CACU,OAAO,IAAI7C,EAAa+C,EAAY7C,EAC9C,CACQ,OAAO,IAAIJ,EAASiD,EAC5B,CACM,MAAM,IAAItB,YAAY,qBAAqBtF,KAAKqG,UACtD,CAEI,MAAAT,IAAUkB,GACR,SAAI9G,KAAKgF,KAAOhF,KAAK+E,QAAQT,QAAUwC,EAAeC,SAAS/G,KAAK+E,QAAQ/E,KAAKgF,UAC/EhF,KAAKgF,QACE,EAGf,CAEI,QAAA0B,CAASM,GACP,IAAIhH,KAAK4F,OAAOoB,GAAhB,CAGA,GAAIhH,KAAKgF,MAAQhF,KAAK+E,QAAQT,OAC5B,MAAM,IAAIgB,YAAY,aAAa0B,4BAErC,MAAM,IAAI1B,YAAY,aAAa0B,iBAA6BhH,KAAKqG,WAJ3E,CAKA,CAEI,KAAAA,GACE,OAAOrG,KAAKgF,KAAOhF,KAAK+E,QAAQT,OAAStE,KAAK+E,QAAQ/E,KAAKgF,MAAQ,IACzE,CAEI,SAAAgB,GACE,OAAOhG,KAAKgF,KAAO,EAAIhF,KAAK+E,QAAQ/E,KAAKgF,KAAO,GAAK,IAC3D,CAEI,QAAAwB,GACE,OAAIxG,KAAKgF,KAAOhF,KAAK+E,QAAQT,QAC3BtE,KAAKgF,OACEhF,KAAK+E,QAAQ/E,KAAKgF,KAAO,IAE3B,IACb,CAEI,OAAAiC,CAAQD,GACN,MAAME,EAAQlH,KAAKwG,WACnB,GAAIU,IAAUF,EACZ,MAAM,IAAI1B,YAAY,aAAa0B,kBAA8BE,MAEnE,OAAOA,CACb,CAEI,iBAAAL,GACE,GAAI7G,KAAKgF,KAAOhF,KAAK+E,QAAQT,QAAU,2BAA2BK,KAAK3E,KAAK+E,QAAQ/E,KAAKgF,OAAQ,CAC/F,MAAMkC,EAAQlH,KAAK+E,QAAQ/E,KAAKgF,MAEhC,OADAhF,KAAKgF,OACEkC,CACf,CACM,OAAO,IACb"}