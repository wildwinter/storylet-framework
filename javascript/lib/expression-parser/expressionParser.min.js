var ExpressionParser=function(t){"use strict";const e=Object.freeze({SINGLEQUOTE:0,ESCAPED_SINGLEQUOTE:1,DOUBLEQUOTE:2,ESCAPED_DOUBLEQUOTE:3});let r=e.SINGLEQUOTE;const s={get StringFormat(){return r},set StringFormat(t){r=t}};class n{constructor(t,e){if(new.target===n)throw new TypeError("Cannot instantiate abstract class ExpressionNode directly");this._name=t,this._precedence=e,this._specificity=0}get specificity(){return this._specificity}evaluate(t,e){throw new Error("Abstract method 'evaluate' not implemented")}dump_structure(t=0){throw new Error("Abstract method 'dump_structure' not implemented")}write(){throw new Error("Abstract method 'write' not implemented")}}class i extends n{constructor(t,e,r,s,n){super(t,n),this._left=e,this._op=r,this._right=s,this._specificity=e.specificity+s.specificity}evaluate(t,e){const r=this._left.evaluate(t,e),[s,n]=this._short_circuit(r);if(s)return e&&e.push(`Evaluated: ${A(r)} ${this._op} (ignore) = ${A(n)}`),n;const i=this._right.evaluate(t,e),o=this._do_eval(r,i);return e&&e.push(`Evaluated: ${A(r)} ${this._op} ${A(i)} = ${A(o)}`),o}_do_eval(t,e){throw new Error("Abstract method '_do_eval' not implemented")}_short_circuit(t){return[!1,null]}dump_structure(t=0){let e="  ".repeat(t)+`${this._name}\n`;return e+=this._left.dump_structure(t+1),e+=this._right.dump_structure(t+1),e}write(){let t=this._left.write(),e=this._right.write();return this._left._precedence<this._precedence&&(t=`(${t})`),this._right._precedence<this._precedence&&(e=`(${e})`),`${t} ${this._op} ${e}`}}class o extends i{constructor(t,e){super("Or",t,"or",e,40),this._specificity+=1}_short_circuit(t){return T(t)?[!0,!0]:[!1,null]}_do_eval(t,e){return T(t)||T(e)}}class a extends i{constructor(t,e){super("And",t,"and",e,50),this._specificity+=1}_short_circuit(t){return T(t)?[!1,null]:[!0,!1]}_do_eval(t,e){return T(t)&&T(e)}}class _ extends i{constructor(t,e){super("Equals",t,"==",e,60)}_do_eval(t,e){return t===(e=S(t,e))}}class u extends i{constructor(t,e){super("NotEquals",t,"!=",e,60)}_do_eval(t,e){return t!==(e=S(t,e))}}class h extends i{constructor(t,e){super("Plus",t,"+",e,70)}_do_eval(t,e){return k(t)+k(e)}}class c extends i{constructor(t,e){super("Minus",t,"-",e,70)}_do_eval(t,e){return k(t)-k(e)}}class p extends i{constructor(t,e){super("Divide",t,"/",e,85)}_do_eval(t,e){if(0===(e=k(e)))throw new Error("Division by zero.");return k(t)/e}}class l extends i{constructor(t,e){super("Multiply",t,"*",e,80)}_short_circuit(t){return 0==k(t)?[!0,0]:[!1,null]}_do_eval(t,e){return k(t)*k(e)}}class d extends i{constructor(t,e){super("GreaterThan",t,">",e,60)}_do_eval(t,e){return k(t)>k(e)}}class m extends i{constructor(t,e){super("LessThan",t,"<",e,60)}_do_eval(t,e){return k(t)<k(e)}}class f extends i{constructor(t,e){super("GreaterThanEquals",t,">=",e,60)}_do_eval(t,e){return k(t)>=k(e)}}class w extends i{constructor(t,e){super("LessThanEquals",t,"<=",e,60)}_do_eval(t,e){return k(t)<=k(e)}}class v extends n{constructor(t,e,r,s){super(t,s),this._operand=r,this._op=e,this._specificity=r.specificity}evaluate(t,e){const r=this._operand.evaluate(t,e),s=this._do_eval(r);return e&&e.push(`Evaluated: ${this._op} ${A(r)} = ${A(s)}`),s}_do_eval(t){throw new Error("Abstract method '_do_eval' not implemented")}dump_structure(t=0){let e="  ".repeat(t)+`${this._name}\n`;return e+=this._operand.dump_structure(t+1),e}write(){let t=this._operand.write();return this._operand._precedence<this._precedence&&(t=`(${t})`),`${this._op} ${t}`}}class E extends v{constructor(t){super("Negative","-",t,90)}_do_eval(t){return-k(t)}}class y extends v{constructor(t){super("Not","not",t,90)}_do_eval(t){return!T(t)}}class $ extends n{constructor(t){super("Boolean",100),this._value=t}evaluate(t,e){return e&&e.push(`Boolean: ${A(this._value)}`),this._value}dump_structure(t=0){return"  ".repeat(t)+`Boolean(${A(this._value)})\n`}write(){return A(this._value)}}class g extends n{constructor(t){super("Number",100),this._value=parseFloat(t)}evaluate(t,e){return e&&e.push(`Number: ${this._value}`),this._value}dump_structure(t=0){return"  ".repeat(t)+`Number(${this._value})\n`}write(){return`${this._value}`}}class b extends n{constructor(t){super("String",100),this._value=t}evaluate(t,e){return e&&e.push(`String: ${N(this._value)}`),this._value}dump_structure(t=0){return"  ".repeat(t)+`String(${N(this._value)})\n`}write(){return N(this._value)}}class x extends n{constructor(t){super("Variable",100),this._name=t}evaluate(t,e){const r=t[this._name];if(void 0===r)throw new Error(`Variable '${this._name}' not found in context.`);if("number"!=typeof r&&"boolean"!=typeof r&&"string"!=typeof r)throw new TypeError(`Variable '${this._name}' must return bool, string, or numeric.`);return e&&e.push(`Fetching variable: ${this._name} -> ${A(r)}`),r}dump_structure(t=0){return"  ".repeat(t)+`Variable(${this._name})\n`}write(){return this._name}}class O extends n{constructor(t,e=[]){super("FunctionCall",100),this._func_name=t,this._args=e}evaluate(t,e){const r=t[this._func_name];if(void 0===r)throw new Error(`Function '${this._func_name}' not found in context.`);const s=this._args.map((r=>r.evaluate(t,e)));if(s.length!==r.length){const t=s.map((t=>A(t))).join(", ");throw new Error(`Function '${this._func_name}' does not support the provided arguments (${t}).`)}const n=r(...s);if("number"!=typeof n&&"boolean"!=typeof n&&"string"!=typeof n)throw new TypeError(`Function '${this._func_name}' must return bool, string, or numeric.`);if(e){const t=s.map((t=>A(t))).join(", ");e.push(`Called function: ${this._func_name}(${t}) = ${A(n)}`)}return n}dump_structure(t=0){let e="  ".repeat(t)+`FunctionCall(${this._func_name})\n`;for(const r of this._args)e+=r.dump_structure(t+1);return e}write(){const t=this._args.map((t=>t.write()));return`${this._func_name}(${t.join(", ")})`}}function T(t){if("boolean"==typeof t)return t;if("number"==typeof t)return 0!==t;if("string"==typeof t)return"true"===t.toLowerCase()||"1"===t;throw new TypeError(`Type mismatch: Expecting bool, but got '${t}'`)}function k(t){if("boolean"==typeof t)return t?1:0;if("number"==typeof t)return t;if("string"==typeof t){if(/^-?\d+(\.\d+)?$/.test(t))return parseFloat(t)}throw new TypeError(`Type mismatch: Expecting number but got '${t}'`)}function S(t,e){if("boolean"==typeof t)return T(e);if("number"==typeof t)return k(e);if("string"==typeof t)return function(t){if("string"==typeof t)return t;if("boolean"==typeof t)return t?"true":"false";if("number"==typeof t)return t.toString();throw new TypeError(`Type mismatch: Expecting string but got '${t}'`)}(e);throw new TypeError(`Type mismatch: unrecognised type for '${t}'`)}function N(t){switch(s.StringFormat){case e.SINGLEQUOTE:return`'${t}'`;case e.ESCAPED_SINGLEQUOTE:return`\\'${t}\\'`;case e.ESCAPED_DOUBLEQUOTE:return`\\"${t}\\"`;case e.DOUBLEQUOTE:default:return`"${t}"`}}function A(t){return"string"==typeof t?N(t):t.toString()}const L=/\s*(>=|<=|==|=|!=|>|<|\(|\)|,|and|&&|or|\|\||not|!|\+|\-|\/|\*|[A-Za-z_][A-Za-z0-9_]*|-?\d+\.\d+|-?\d+|"[^"]*"|'[^']*'|true|false|True|False)\s*/g;return t.BinaryOp=i,t.ExpressionNode=n,t.ExpressionParser=class{constructor(){this._tokens=[],this._pos=0}parse(t){this._tokens=this.tokenize(t),this._pos=0;const e=this._parse_or();if(this._pos<this._tokens.length)throw new SyntaxError(`Unexpected token '${this._tokens[this._pos]}' at position ${this._pos}`);return e}tokenize(t){const e=t.matchAll(L),r=[];for(const t of e)t[1]&&r.push(t[1]);if(0===r.length)throw new SyntaxError(`No tokens were recognized in expression: '${t}'`);return r}_parse_or(){let t=this._parse_and();for(;this._match("or")||this._match("||");)t=new o(t,this._parse_and());return t}_parse_and(){let t=this._parse_binary_op();for(;this._match("and")||this._match("&&");)t=new a(t,this._parse_binary_op());return t}_parse_math_add_sub(){let t=this._parse_math_mul_div();for(;this._match("+","-");){t="+"===(this._previous()||"")?new h(t,this._parse_math_mul_div()):new c(t,this._parse_math_mul_div())}return t}_parse_math_mul_div(){let t=this._parse_unary_op();for(;this._match("*","/");){t="*"===(this._previous()||"")?new l(t,this._parse_unary_op()):new p(t,this._parse_unary_op())}return t}_parse_binary_op(){let t=this._parse_math_add_sub();for(;this._match("==","!=",">","<",">=","<=","=");){const e=this._previous()||"";"="===e||"=="===e?t=new _(t,this._parse_math_add_sub()):"!="===e?t=new u(t,this._parse_math_add_sub()):">"===e?t=new d(t,this._parse_math_add_sub()):"<"===e?t=new m(t,this._parse_math_add_sub()):">="===e?t=new f(t,this._parse_math_add_sub()):"<="===e&&(t=new w(t,this._parse_math_add_sub()))}return t}_parse_unary_op(){return this._match("not")||this._match("!")?new y(this._parse_unary_op()):this._match("-")?new E(this._parse_unary_op()):this._parse_term()}_parse_string_literal(){const t=this._peek();return t&&(t.startsWith('"')&&t.endsWith('"')||t.startsWith("'")&&t.endsWith("'"))?(this._advance(),new b(t.slice(1,-1))):null}_parse_term(){if(this._match("(")){const t=this._parse_or();return this._consume(")"),t}if(this._match("true")||this._match("True"))return new $(!0);if(this._match("false")||this._match("False"))return new $(!1);if(/^-?\d+(\.\d+)?$/.test(this._peek()||""))return new g(this._advance()||"");const t=this._parse_string_literal();if(null!==t)return t;const e=this._match_identifier();if(e){if(this._match("(")){const t=[];if(!this._match(")")){for(t.push(this._parse_or());this._match(",");)t.push(this._parse_or());this._consume(")")}return new O(e,t)}return new x(e)}throw new SyntaxError(`Unexpected token: ${this._peek()}`)}_match(...t){return!!(this._pos<this._tokens.length&&t.includes(this._tokens[this._pos]))&&(this._pos++,!0)}_consume(t){if(!this._match(t)){if(this._pos>=this._tokens.length)throw new SyntaxError(`Expected '${t}' but expression ended.`);throw new SyntaxError(`Expected '${t}' but found '${this._peek()}'`)}}_peek(){return this._pos<this._tokens.length?this._tokens[this._pos]:null}_previous(){return this._pos>0?this._tokens[this._pos-1]:null}_advance(){return this._pos<this._tokens.length?(this._pos++,this._tokens[this._pos-1]):null}_expect(t){const e=this._advance();if(e!==t)throw new SyntaxError(`Expected '${t}', but found '${e}'`);return e}_match_identifier(){if(this._pos<this._tokens.length&&/^[A-Za-z_][A-Za-z0-9_]*$/.test(this._tokens[this._pos])){const t=this._tokens[this._pos];return this._pos++,t}return null}},t.FunctionCall=O,t.LiteralBoolean=$,t.LiteralNumber=g,t.LiteralString=b,t.OpAnd=a,t.OpDivide=p,t.OpEquals=_,t.OpGreaterThan=d,t.OpGreaterThanEquals=f,t.OpLessThan=m,t.OpLessThanEquals=w,t.OpMinus=c,t.OpMultiply=l,t.OpNegative=E,t.OpNot=y,t.OpNotEquals=u,t.OpOr=o,t.OpPlus=h,t.STRING_FORMAT=e,t.UnaryOp=v,t.Variable=x,t.Writer=s,t}({});
//# sourceMappingURL=expressionParser.min.js.map
